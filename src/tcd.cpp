/************************************************************************\
 
 * This file implements the main B&B routine of the TCD algorithm [1]
 
 * Signature:
               R = tcd_test(S1,S2,L,opt);
 * Input:
   S1,S2:      the integral images of vid1 and vid2 respectively (can be 
               generated by provided matlab script initSoft.m)
   L:          minimal length allowed in TCD (\ell)
   opt: 
     .maxIter:   max #iter where TCD terminates [default:1e4]
     .nRes:      number of resulting commonalties [default:1]
     .dist:      metrics of interest ("l1","l2","X2","int") [default:"l1"]
     .isVerbose: verbose or not [default:true]

 * Output:
   R:          discovered rectangle sets in the temporal search space
   info:       some info output from the tcd algorithm

 * Ref: [1] Unsupervised Temporal Commonality Discovery, ECCV 2012.
 
 * Aug-8-2014 updated by Wen-Sheng Chu (wschu@cmu.edu)
 
\***********************************************************************/

#include "mex.h" /* Always include this */
#include "tcd.h"

#define EPS (float)1.192093e-07 // FLT_EPSILON

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) {
  
  // Input checks
  if (nrhs < 3) {
    printUsg();
    return;
  }
  
  #define S1 prhs[0]
  #define S2 prhs[1]
  
  if(!IS_REAL_2D(S1)) // check S1
    mexErrMsgTxt("S1 must be a real 2D matrix.");
  if(!IS_REAL_2D(S2)) // check S2
    mexErrMsgTxt("S2 must be a real 2D matrix.");
  
   // init
  float* S1r = (float*)mxGetPr(S1);
  float* S2r = (float*)mxGetPr(S2);
  short  B   = static_cast<short>(mxGetM(S1)); // num of bins   
  short  m   = static_cast<short>(mxGetN(S1))-1; // length of Seq1
  short  n   = static_cast<short>(mxGetN(S2))-1; // length of Seq2
    
   // Get parameters
  unsigned int maxIter;
  short        nRes;
  short        L;
  string       dist;
  bool         isVerbose;
  getParams(nrhs, prhs, L, maxIter, nRes, dist, isVerbose);
  
  Rset  R1, R2; // Rectangle sets for splitting
  float lb, ub; // lower and upper bounds
  State topS;   // top state
  priority_queue<State, vector<State>, CompareState> Q; // priority queue
  priority_queue<State, vector<State>, CompareState> Qtmp; // priority queue
  
  if (dist.compare("l1")!=0 && dist.compare("l2")!=0 && dist.compare("X2")!=0 && dist.compare("int")!=0) {
    mexPrintf("!!! We do not support \"%s\" distance. Please read the usage carefully!\n",dist.c_str());
    mexPrintf("!!! Please select from these distance options: [\"l1\",\"l2\",\"X2\",\"int\"]\n");
    return;
  }
  
  // Init output structure
  int          dimOut1[2] = {1,nRes};
  int          numFields1 = 3;
  const char*  fieldNames1[] = { "lo", "hi", "lb" };
  plhs[0] = mxCreateStructArray(2, dimOut1, numFields1, fieldNames1); // creates fields
  
  int          dimOut2[2] = {1,nRes};
  int          numFields2 = 1;
  const char*  fieldNames2[] = { "nIter" };
  plhs[1] = mxCreateStructArray(2, dimOut2, numFields2, fieldNames2);   // creates fields
  
  
  // Main loop below
  mexPrintf("===============================================\n");
  mexPrintf("+ Running TCD w/ %s distance\n", dist.c_str());
  mexPrintf("===============================================\n");
  for (short iRes=0; iRes<nRes; iRes++) {
    
    // init
    unsigned int nIter  = 0;      // counter for #iteration
    bool         isConv = false;  // flag for convergence
        
    
    Rset Rout = { {0,0,0,0}, {0,0,0,0}, false };
    
    // Update Q
    Rset R;
    if (iRes == 0) {
      Rset R0 = { {1,1,1,1}, {m,m,n,n}, true }; // init R with everything
      R = R0;
    } else {
      Rout = topS.R;
      mexPrintf("+ Updating Q (size=%d -> ", Q.size());
      
      // Clean Qtmp
      while (!Qtmp.empty())
        Qtmp.pop();
      
      // Copy Q into Qtmp and clean Q
      while(!Q.empty()) {
        Qtmp.push(Q.top());
        Q.pop();
      }
      
      // Being to update Q
      State tmpS;
      while(!Qtmp.empty()) {
        tmpS = Qtmp.top();
        Qtmp.pop();

        // Update R into R1 and R2
        Rset R1, R2;
        updateR(topS.R, tmpS.R, m, n, R1, R2);
        
        // Push {bound(R1), R1} to Q
        getBounds(S1r, S2r, B, R1, lb, ub, dist);
        if (R1.isValid()) {
          State St1 = {lb, R1};
          Q.push(St1);
        }
        
        // Push {bound(R2), R2} to Q
        getBounds(S1r, S2r, B, R2, lb, ub, dist);
        if (R2.isValid()) {
          State St2 = {lb, R2};
          Q.push(St2);
        }
      }
      mexPrintf("%d)\n",Q.size());
      
      // Get topS
      topS = Q.top();
      R = topS.R;
      Q.pop();
    }
    
    while (!isConv) {
      nIter++;

      // Split rect set into R1 and R2
      split(R, R1, R2);

      // Push R1 into queue if valid
      if (isvalid(R1, L)) {
        getBounds(S1r, S2r, B, R1, lb, ub, dist);
        State S = {lb, R1};
        Q.push(S);
      }

      // Push R2 into queue if valid
      if (isvalid(R2, L)) {
        getBounds(S1r, S2r, B, R2, lb, ub, dist);
        State S = {lb, R2};
        Q.push(S);
      }

      // Update R by top state
      topS = Q.top();
      R = topS.R;
      Q.pop();
      
      if (isOverlap(Rout, R)) {
        mexPrintf("Rout: "); Rout.disp();
        mexPrintf("R: ");  R.disp();
        return;
      }

      // Check stopping criterion
      if (nIter % 100 == 0 && isVerbose) {
        mexPrintf("  # Iter%4d: ",nIter);
        topS.disp();
      }
      if (nIter >= maxIter) {
        mexPrintf("  # MaxIter%d reached: ", maxIter);
        topS.disp();
        isConv = true;
      }
      if (isUniqR(R)) {
        mexPrintf("  # Iter%4d: ",nIter);
        topS.disp();
        isConv = true;
      }
    } // end of main loop
    
    // Assign output structure
    setField<short>(&plhs[0], iRes, "lo", 4, mxINT16_CLASS, topS.R.lo);    // set lo
    setField<short>(&plhs[0], iRes, "hi", 4, mxINT16_CLASS, topS.R.hi);    // set hi
    setField<float>(&plhs[0], iRes, "lb", 1, mxSINGLE_CLASS, &topS.bound); // set lb
    setField<unsigned int>(&plhs[1], iRes, "nIter", 1, mxUINT16_CLASS, &nIter); // set info.nIter
    
  } // end of iRes
    
  return;
}

// Set output struct with a specific type of data
template<typename T>
void setField(mxArray** A, const int structIdx, const char* fieldname, const int size, mxClassID mxType, const T* value) {
  mxArray *fieldValLo = mxCreateNumericMatrix(1, size, mxType, mxREAL);
  T* loVal = (T*)mxGetData(fieldValLo);
  memcpy(loVal, value, sizeof(T)*size);
  mxSetFieldByNumber(*A, structIdx, mxGetFieldNumber(*A,fieldname), fieldValLo);
}

// Get bounds according to different distance metrics
int getBounds(float* S1r, float* S2r, const short& B, const Rset& R, float& lb, float& ub, const string dist) {
  
  // Get |A+|
  float* Apv = new float[B];
  vSub(S1r + B*(R.hi[1]), S1r + B*(R.lo[0]-1), B, &Apv);
  float  Ap = vSum(Apv,B) + EPS; // |A+|
  
  // Get |k+|
  float* Bpv = new float[B];
  vSub(S2r + B*(R.hi[3]), S2r + B*(R.lo[2]-1), B, &Bpv);
  float Bp = vSum(Bpv, B) + EPS; // |B+|
      
  // Get |A-|
  float  Am = EPS; // |A-|
  float* Amv = new float[B];
  if (R.lo[1] >= R.hi[0]) {
    vSub(S1r + B*(R.lo[1]), S1r + B*(R.hi[0]-1), B, &Amv);
    Am += vSum(Amv, B);
  } else {
    memset(Amv, 0, sizeof(float)*B);
  }
  
  // Get |B-|
  float  Bm = EPS;
  float* Bmv = new float[B];
  if (R.lo[3] >= R.hi[2]) {
    vSub(S2r + B*(R.lo[3]), S2r + B*(R.hi[2]-1), B, &Bmv);
    Bm += vSum(Bmv, B);
  } else {
    memset(Bmv, 0, sizeof(float)*B);
  }

  lb = 0.0f; 
  ub = 0.0f;
  short i;
  if (dist.compare("l1")==0) {
    for (i=0; i<B; i++) {
      lb += max(Amv[i]/Ap, Bmv[i]/Bp) - min(Apv[i]/Am, Bpv[i]/Bm);
      ub += max(Apv[i]/Am, Bpv[i]/Bm) - min(Amv[i]/Ap, Bmv[i]/Bp);
    }
  
  } else if (dist.compare("l2")==0) {
    for (i=0; i<B; i++) {
      lb += pow(max(0.0f, max(Amv[i]/Ap, Bmv[i]/Bp) - min(Apv[i]/Am, Bpv[i]/Bm)), 2.0f);
      ub += pow(max(Apv[i]/Am, Bpv[i]/Bm) - min(Amv[i]/Ap, Bmv[i]/Bp), 2.0f);
    }
  } else if (dist.compare("X2")==0) {
    for (i=0; i<B; i++) {
      lb += pow(max(0.0f, max(Amv[i]/Ap, Bmv[i]/Bp) - min(Apv[i]/Am, Bpv[i]/Bm)), 2.0f) \
              / (Apv[i]/Am + Bpv[i]/Bm + EPS);
      ub += pow(max(Apv[i]/Am, Bpv[i]/Bm) - min(Amv[i]/Ap, Bmv[i]/Bp), 2.0f) \
              / (Amv[i]/Ap + Bmv[i]/Bp + EPS);
    }
  } else if (dist.compare("int")==0) {
    for (i=0; i<B; i++) {
      lb -= min(Apv[i]/Am, Bpv[i]/Bm);
      ub -= min(Amv[i]/Ap, Bmv[i]/Bp);
    }
  }
  
  delete[] Apv; 
  delete[] Bpv;
  delete[] Amv;
  delete[] Bmv;
  return 0;
}

// Vector substraction
void vSub(const float* v1, const float* v2, const short& B, float** out) {
  for (short i=0; i<B; i++) 
    (*out)[i] = v1[i] - v2[i];
}

// Vector sum
float vSum(const float* v, const short& B) {
  float out = 0.0;
  for (short i=0; i<B; i++)
    out += v[i];
  return out;
}

// Check if a given R is unique
bool isUniqR(const Rset& R) {
  return (R.lo[0]==R.hi[0]) && (R.lo[1]==R.hi[1]) && (R.lo[2]==R.hi[2]) && (R.lo[3]==R.hi[3]); 
}

// Check if a given rectangle set is valid
// In matlab: (R(1)<=R(4)-L) & (R(5)<=R(8)-L)
bool isvalid(const Rset& R, const short L) {
  return (R.lo[0]<=R.hi[1]-L) && (R.lo[2]<=R.hi[3]-L);
}


// Rectify R if necessary
void rectify(Rset& R) {
  for (int i=0; i<4; i++)
    if (R.lo[i] > R.hi[i])
      swap(R.lo[i], R.hi[i]);
}

// Split a given rectangle R into two subsets R1 and R2 s.t. R=union(R1,R2)
void split(const Rset& R, Rset& R1, Rset& R2) {
  R1 = R;
  R2 = R;
  int ms = maxside(R);
  short sloc = (short)floor((float)(R1.lo[ms]+R1.hi[ms])/2); // split location
  R1.hi[ms] = sloc;
  R2.lo[ms] = sloc + 1;
  
  rectify(R1);
  rectify(R2);
}

// Find the maximal side in R
int maxside(const Rset& R) {
  short I[4]; // I for the 4 intervals B1,E1,B2,E2
  for (int i=0; i<4; i++)
    I[i] = R.hi[i] - R.lo[i];
  return (int)(distance(I, max_element(I, I+4)));
}

// Print the usage of TCD routine
void printUsg() {
  mexPrintf("  Usage: \n");
  mexPrintf("         [R,info] = tcd(S1,S2,L,[opt]);\n");
  mexPrintf("  Inputs:\n");
  mexPrintf("    S1,S2: integral images of vid1 and vid2 respectively (can be generated\n");
  mexPrintf("           by provided matlab script initHard.m or initSoft.m)\n");
  mexPrintf("    L:     minimal length allowed in TCD (\\ell in the paper)\n");
  mexPrintf("    opt:   options\n");
  mexPrintf("      .maxIter:   max #iter where TCD terminates [default:1e4]\n");
  mexPrintf("      .nRes:      number of resulting commonalties [default:1]\n");
  mexPrintf("      .dist:      metrics of interest (\"l1\",\"l2\",\"X2\",\"int\") [default:\"l1\"]\n");
  mexPrintf("      .isVerbose: verbose or not [default:true]\n");
  mexPrintf("  Outputs:\n");
  mexPrintf("    R:     discovered rectangle sets in the temporal search space\n");
  mexPrintf("    info:  some info output from the TCD algorithm\n\n");
}

// Get parameters from inputs
int getParams(const int nrhs, const mxArray *prhs[], short& L, unsigned int& maxIter, \
			  short& nRes, string& dist, bool& isVerbose) {
  
  // Get L
  L = (short)mxGetScalar(prhs[2]);
  
  // Get options
  maxIter   = (unsigned int)10000;
  nRes      = (unsigned int)1;
  dist      = "l1";
  isVerbose = true;
    
  if (nrhs >= 4) {
    // Get option "maxIter"
    mxArray* bufMaxIter = mxGetField(prhs[3],0,"maxIter");
    if ( bufMaxIter != NULL )
      maxIter = (unsigned int)mxGetScalar(bufMaxIter);

	// Get option "nRes"
    mxArray* bufRes = mxGetField(prhs[3],0,"nRes");
    if ( bufRes != NULL )
      nRes = (short)mxGetScalar(bufRes);

    // Get option "dist"
    mxArray* bufDist = mxGetField(prhs[3],0,"dist");
    if ( bufDist != NULL )
      dist = mxArrayToString(bufDist);
        
    // Get option "isVerbose"
    mxArray* bufVerb = mxGetField(prhs[3],0,"isVerbose");
    if ( bufVerb != NULL )
      isVerbose = (mxGetScalar(bufVerb) == 1.0f);
  }
    
  // Display
  mexPrintf("+ Load parameters: L=%d, ", L);
  mexPrintf("maxIter=%d, nRes=%d, dist=\"%s\", isVerbose=%d\n", maxIter, nRes, dist.c_str(), isVerbose);
  return 0;
}


// Update rectangle set to avoid collision
// Input R is split and output as R1 and R2
void updateR(Rset& rect, Rset& R, const short m, const short n, Rset& R1, Rset& R2) {
  
  short* B1lo = &R.lo[0]; short* B1hi = &R.hi[0];
  short* E1lo = &R.lo[1]; short* E1hi = &R.hi[1];
  short* B2lo = &R.lo[2]; short* B2hi = &R.hi[2];
  short* E2lo = &R.lo[3]; short* E2hi = &R.hi[3];
  
  short* l = &rect.lo[0]; short* r = &rect.lo[1];
  short* t = &rect.lo[2]; short* b = &rect.lo[3];
  
  copyR(R, R1);
  copyR(R, R2);
  
  // upper right corner of rect is in the bottom left region of R
  if (ismember<short>(*r, *B1lo, *B1hi) && ismember<short>(*t, *E2lo, *E2hi)) {
    if (*r==m) // r reaches the last frame
      R1.setValid(false);
    else       // Update B1(1) to r+1
      R1.lo[0] = *r+1;
    if (*t==1) // t is the 1st frame
      R2.setValid(false);
    else       // Update E2(2) to t-1
      R2.hi[3] = *t-1; 
  }

  // bottom right corner of rect is in the top left region of R
  else if (ismember<short>(*r, *B1lo, *B1hi) && ismember<short>(*t, *B2lo, *B2hi)) {
    if (*r==m) // r reaches the last frame
      R1.setValid(false);
    else       // Update B1(1) to r+1
      R1.lo[0] = *r+1;
    if (*b==n) // b reaches the last frame
      R2.setValid(false);
    else       // Update B2(1) to b+1
      R2.lo[2] = *b+1; 
  }

  // bottom left corner of rect is in the top right region of R
  else if (ismember<short>(*l, *E1lo, *E1hi) && ismember<short>(*b, *B2lo, *B2hi)) {
    if (*l==1) // l is the first frame
      R1.setValid(false);
    else       // Update E1(2) to l-1
      R1.hi[1] = *l-1;
    if (*b==n) // b reaches the last frame
      R2.setValid(false);
    else       // Update B2(1) to b+1
      R2.lo[2] = *b+1; 
  }

  // top left corner of rect is in the bottom right region of R
  else if (ismember<short>(*l, *E1lo, *E1hi) && ismember<short>(*t, *E2lo, *E2hi)) {
    if (*l==1) // l is the first frame
      R1.setValid(false);
    else       // Update E1(2) to l-1
      R1.hi[1] = *l-1;
    if (*t==1) // t is the first frame
      R2.setValid(false);
    else       // Update E2(2) to t-1
      R2.hi[3] = *t-1; 
  }

  else if (ismember<short>(*b, *B2lo, *B2hi)) {
    R2.setValid(false);
    if (*b==n) // b reaches the last frame
      R1.setValid(false);
    else       // Update B2(1) to b+1
      R1.lo[2] = *b+1; 
  }

  else if (ismember<short>(*r, *B1lo, *B1hi)) {
    R2.setValid(false);
    if (*r==m) // r reaches the last frame
      R1.setValid(false);
    else       // Update B1(1) to r+1
      R1.lo[0] = *r+1; 
  }

  else if (ismember<short>(*t, *E2lo, *E2hi)) {
    R2.setValid(false);
    if (*t==1) // t is the first frame
      R1.setValid(false);
    else       // Update E2(2) to t-1
      R1.hi[3] = *t-1; 
  }

  else if (ismember<short>(*l, *E1lo, *E1hi)) {
    R2.setValid(false);
    if (*l==1) // l is the first frame
      R1.setValid(false);
    else       // Update E1(2) to l-1
      R1.hi[1] = *l-1; 
  }

  else if (*l>*E1hi || *t>*E2hi || *r<*B1lo || *b<*B2lo) {// keep R1
    R2.setValid(false);
  }
  
  else { 
    R1.setValid(false);
    R2.setValid(false);
  }
  
  // Double check the overlap
  if (isOverlap(rect, R1) && R1.isValid()) {
    mexPrintf("rect: ");rect.disp();
    mexPrintf("R1: ");R1.disp();
    return;
  }
  if (isOverlap(rect, R2) && R2.isValid()) {
    mexPrintf("rect: ");rect.disp();
    mexPrintf("R2: ");R2.disp();
    return;
  }
}

// Copy contents for Rset
void copyR(Rset& Rin, Rset& Rout) {
  for (int i=0; i<4; i++) {
    Rout.lo[i] = Rin.lo[i];
    Rout.hi[i] = Rin.hi[i];
  }
  Rout.bValid = Rin.bValid;
}

// Copy contents for State
void copyS(State& Sin, State& Sout) {
  copyR(Sin.R, Sout.R);
  Sout.bound = Sin.bound;
}

// Check if a is within the interval
template<typename T> 
bool ismember(T a, T interval_begin, T interval_end) {
  return (a >= interval_begin) && (a <= interval_end);
}

// Check if a rectangle overlaps with a Rset
bool isOverlap(Rset& rect, Rset& R) {
  short* B1lo = &R.lo[0]; short* B1hi = &R.hi[0];
  short* E1lo = &R.lo[1]; short* E1hi = &R.hi[1];
  short* B2lo = &R.lo[2]; short* B2hi = &R.hi[2];
  short* E2lo = &R.lo[3]; short* E2hi = &R.hi[3];
  
  short* l = &rect.lo[0]; short* r = &rect.lo[1];
  short* t = &rect.lo[2]; short* b = &rect.lo[3];
  
  if (*r<*B1lo || *b<*B2lo || *l>*E1hi || *t>*E2hi || (*l>*B1hi && *t>*B2hi && *r<*E1lo && *b<*E2lo))
    return false;
  else
    return true;
}
